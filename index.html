MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                                    mesh1 = new THREE.Mesh(geometry1, material1);
                                    // Поворачиваем плоскость
                                    mesh1.rotation.x = -Math.PI / 2;
                                    // Добавляем плоскость в контейнер
                                    markerRoots[i].add(mesh1);
                                    resolve(imageFiles[i])
                                }).then(image => {
                                    console.log(`${image} loaded`)
                                }))
                            }
                            break;
                        // Если контент под маркер это видео
                        case 'video':
                            // Объявляем плоскость под видео
                            let geometry2 = new THREE.PlaneBufferGeometry(2, 2, 4, 4);
                            // Объявляем и загружаем видео
                            let video = document.createElement('video');
                            video.src = `${videoFiles[i]}`;
                            // Устанавлием видео на автоповтор в зависимости от значения в массиве
                            if (repeatOptions[i]) {
                                video.addEventListener('ended', () => {
                                    video.play();
                                })
                            }
                            // Добавляем видео в массив аудио контента
                            if (patternBarcode[i] === -1) {
                                patternsSound.set(i, video);
                            } else {
                                barcodesSound.set(patternBarcode[i], video);
                            }
                            // Перенаправляем текстуру из видео в материал для плоскости
                            let texture2 = new THREE.VideoTexture(video);
                            texture2.minFilter = THREE.LinearFilter;
                            texture2.magFilter = THREE.LinearFilter;
                            texture2.format = THREE.RGBFormat;
                            let material2 = new THREE.MeshBasicMaterial({ map: texture2 });
                            mesh2 = new THREE.Mesh(geometry2, material2);
                            // Поворачиваем плоскость
                            mesh2.rotation.x = -Math.PI / 2;
                            // Добавляем плоскость в контейнер
                            markerRoots[i].add(mesh2);
                            break;
                        case 'controller':
                            controller = new THREE.Mesh(
                                new THREE.CubeGeometry(10, 0.15, 0.15),
                                new THREE.MeshBasicMaterial({ color: 'green' })
                            );
                            controller.rotation.y = Math.PI / 2;
                            controller.position.y = 0.125;
                            controller.position.z = -4.5;
                            markerRoots[i].add(controller);
                            break;
                        default:
                            // Если никакого контента добавленно не было, добавляем белую плоскость
                            mesh11 = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1),
                                                new THREE.MeshBasicMaterial({ color: '#fff' }));
                            // Поворачиваем плоскость
                            mesh11.rotation.x = -Math.PI / 2;
                            // Добавляем плоскость в контейнер
                            markerRoots[i].add(mesh11);
                            break;
                    }
    
                    // Если имеются аудио файлы настраиваем их и добавляем в массив аудио контента
                    if (audioFiles[i]) {
                        contentPromises.push(new Promise((resolve, reject) => {
                            audioLoader.load(`${audioFiles[i]}`, function (buffer) {
                                // Создаём аудио источник
                                let sound = new THREE.Audio(listener);
                                sound.name = `${audioFiles[i]}`;
                                sound.setBuffer(buffer);
                                // Устанавлием аудио на автоповтор в зависимости от значения в массиве
                                if (repeatOptions[i]) {
                                    sound.setLoop(true);
                                }
                                if (patternBarcode[i] === -1) {
                                    patternsSound.set(i, sound);
                                } else {
                                    barcodesSound.set(patternBarcode[i], sound);
                                }
                                resolve(sound)
                            });
                        }).then((sound) => {
                            sound.play()
                            sound.stop()
                            console.log(`${sound.name} loaded`)
                        }))
                    }
                }
  
                Promise.all(contentPromises)
                    .then(() => {
                        console.log('Most of the content loaded')
                        audioInitialized = !audioInitialized;
                    });

                // Добавляем главный контейнер на сцену
                scene.add(mainContainer);
            }

            function checkController() {
                if (controller) {
                    mainContainer.traverse((object) => {
                        if (object.isMesh && object !== controller) {
                            if (detectCollisionCubes(object, controller)) {
                                object.material.color.set('red')
                            } else {
                                object.material.color.set('white')
                            }
                        }
                    });
                }
            }

            function detectCollisionCubes (object1, object2) {
                object1.geometry.computeBoundingBox();
                object2.geometry.computeBoundingBox();
                object1.updateMatrixWorld();
                object2.updateMatrixWorld();

                const box1 = object1.geometry.boundingBox.clone();
                box1.applyMatrix4(object1.matrixWorld);

                const box2 = object2.geometry.boundingBox.clone();
                box2.applyMatrix4(object2.matrixWorld);

                return box1.intersectsBox(box2);
            };
    
            // Обновляем AR контент на каждый кадр
            function update() {
                if (arToolkitSource.ready !== false) {
                    arToolkitContext.update(arToolkitSource.domElement);
                    if (audioInitialized) {
                        if (barcodesID.length) {
                            barcodesID.forEach((elem, index) => {
                                if (arToolkitContext.arController.barcodeMarkers[elem].inCurrent) {
                                    let sound = barcodesSound.get(elem);
                                    if (sound && !sound.isPlaying) sound.play();
                                } else {
                                    let sound = barcodesSound.get(elem);
                                    if (sound && sound.nodeName === 'VIDEO') {
                                        if (!sound.paused) sound.pause()
                                    }
                                    if (sound && sound.isPlaying) sound.stop();
                                }
                            })
                        }
                        if (patternsID.length) {
                            for (let index = 0; index < patternsID.length; index++) {
                                if (arToolkitContext.arController.patternMarkers[index].inCurrent) {
                                    let patternID = (arToolkitContext.arController.patternMarkers[index].markerWidth - 1) * patternIdOffset - 1;
                                    patternID = Math.round(patternID)
                                    let sound = patternsSound.get(patternID);
                                    if (sound && !sound.isPlaying) sound.play();
                                } else {
                                    let patternID = (arToolkitContext.arController.patternMarkers[index].markerWidth - 1) * patternIdOffset - 1;
                                    patternID = Math.round(patternID)
                                    let sound = patternsSound.get(patternID);
                                    if (sound && sound.nodeName === 'VIDEO') {
                                        if (!sound.paused) sound.pause()
                                    }
                                    if (sound && sound.isPlaying) sound.stop();
                                }
                            }
                        }
                    }
                }
            }
    
            // Рендерим сцену на каждый кадр
            function render() {
                renderer.render(scene, camera);
            }
    
            // Запускаем цикл анимации
            function animate(time) {
                // Запускаем цикл в петлю
                requestAnimationFrame(animate);
                deltaTime = clock.getDelta();
                totalTime += deltaTime;
                update();
                checkController();
                render();
            }
        </script>
    
    </body>
    
    </html>
  
